{"version":3,"sources":["time-segments.js"],"names":[],"mappings":"AAAA,AAAC,CAAA,UAAU,QAAQ,SAAS;AAC1B,SAAO,YAAY,YAAY,OAAO,WAAW,cAAc,OAAO,UAAU,QAAQ,QAAQ,eAAe,QAAQ,aACvH,OAAO,WAAW,cAAc,OAAO,MAAM,OAAO,CAAC,cAAc,WAAW,WAC9E,OAAO,eAAe,QAAQ,OAAO,GAAG,OAAO;GAC/C,MAAM,UAAU,GAAG,QAAQ;AAAE;;AAE7B,MAAI,eAAe;;;AAGjB,aAAO,iBAAC,QAAQ,OAAO,SAAS;AAC9B,cAAQ,SAAS;AACjB,gBAAU,WAAW;AACrB,QAAE,SAAS,SAAS;AAClB,wBAAgB;AAChB,sBAAc;;;AAGhB,UAAI,WAAW;UAAI;UAAO;UAAK;UAAe;AAC9C,eAAS,EAAE,MAAM,QACd,QACA,IAAI,UAAA,GAAK;AACR,gBAAQ,EAAE,QAAQ;AAClB,cAAM,EAAE,QAAQ;AAChB,wBAAgB,OAAO,SAAS;AAChC,sBAAc,OAAO,SAAS;AAC9B,YAAI,CAAC,CAAC,iBAAiB,CAAC,gBAAgB,CAAC,QAAQ,YAAY;AAC3D,gBAAM,IAAI,MAAM;;AAElB,gBAAQ,OAAO,SAAS,SAAS,QAAQ,OAAO,IAAI,OAAO,QAAQ;AACnE,cAAM,OAAO,SAAS,OAAO,MAAM,OAAO,IAAI,KAAK,QAAQ;AAC3D,eAAO;AACL,iBAAA,OAAO,KAAA;AACP,oBAAU,EAAE,MAAM;;SAGrB,OAAO,UAAA;eAAK,EAAE,MAAM;SACpB,KAAK,UAAA,GAAK;;;AAGT,YAAI,cAAc,OAAO,IAAI,EAAE,OAAO,QAAQ;AAC9C,YAAI,YAAY,OAAO,IAAI,EAAE,KAAK,MAAM,OAAO,IAAI,GAAG;;;AAGtD,YAAI;AACJ,aAAI,IAAI,IAAI,GAAG,WAAW,UAAU,KAAK,aAAa,QAAQ,IAAI,UAAU,KAAK;AAC/E,yBAAe,OAAO,IAAI,aAAa,IAAI,GAAG,OAAO;AACrD,cAAI,CAAC,SAAS,eAAe;AAAE,qBAAS,gBAAgB;;AACxD,mBAAS,cAAc,KAAK,EAAE;;;AAGpC,aAAO;;;;AAIX,MAAI,gBAAgB;;AAEpB,SAAO","file":"time-segments.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('underscore'), require('moment')) :\n  typeof define === 'function' && define.amd ? define(['underscore', 'moment'], factory) :\n  global.TimeSegments = factory(global._, global.moment)\n}(this, function (_, moment) { 'use strict';\n\n  var TimeSegments = {\n\n    // Segment an array of events by scale\n    segment(events, scale, options) {\n      scale = scale || 'weeks';\n      options = options || {};\n      _.defaults(options, {\n        startAttribute: 'start',\n        endAttribute: 'end'\n      });\n\n      var segments = {}, start, end, startIsMoment, endIsMoment;\n      events = _.chain(events)\n        .clone()\n        .map(e => {\n          start = e[options.startAttribute];\n          end = e[options.endAttribute];\n          startIsMoment = moment.isMoment(start);\n          endIsMoment = moment.isMoment(end);\n          if ((!startIsMoment || !endIsMoment) && !options.timeFormat) {\n            throw new Error('Parsing strings into dates requires the `timeFormat` option.');\n          }\n          start = moment.isMoment(start) ? start : moment.utc(start, options.timeFormat);\n          end = moment.isMoment(end) ? end : moment.utc(end, options.timeFormat);\n          return {\n            start, end,\n            original: _.clone(e)\n          };\n        })\n        .sortBy(e => e.start.unix())\n        .each(e => {\n          // Calculate the duration of the event; this determines\n          // how many segments it will be in\n          var startMoment = moment.utc(e.start).startOf(scale);\n          var endMoment = moment.utc(e.end).endOf(scale).add(1, 'milliseconds');\n\n          // For each duration, add the event to the corresponding segment\n          var segmentStart;\n          for(var i = 0, duration = endMoment.diff(startMoment, scale); i < duration; i++) {\n            segmentStart = moment.utc(startMoment).add(i, scale).unix();\n            if (!segments[segmentStart]) { segments[segmentStart] = []; }\n            segments[segmentStart].push(e.original);\n          }\n        });      \n      return segments;\n    }\n  };\n\n  var time_segments = TimeSegments;\n\n  return time_segments;\n\n}));\n"],"sourceRoot":"/source/"}