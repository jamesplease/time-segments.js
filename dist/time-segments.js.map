{"version":3,"sources":["time-segments.js"],"names":[],"mappings":"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","file":"time-segments.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'moment'], factory);\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore');\n    var moment = require('moment');\n    module.exports = factory(_, moment);\n  } else {\n    root.TimeSegments = factory(root._, root.moment);\n  }\n})(this, function(_, moment) {\n  'use strict';\n\n  import _ from 'underscore';\n  import moment from 'moment';\n  \n  var TimeSegments = {\n  \n    // Segment an array of events by scale\n    segment(events, scale, options) {\n      scale = scale || 'weeks';\n      options = options || {};\n      _.defaults(options, {\n        startAttribute: 'start',\n        endAttribute: 'end'\n      });\n  \n      var segments = {}, start, end, startIsMoment, endIsMoment;\n      events = _.chain(events)\n        .clone()\n        .map(e => {\n          start = e[options.startAttribute];\n          end = e[options.endAttribute];\n          startIsMoment = moment.isMoment(start);\n          endIsMoment = moment.isMoment(end);\n          if ((!startIsMoment || !endIsMoment) && !options.timeFormat) {\n            throw new Error('Parsing strings into dates requires the `timeFormat` option.');\n          }\n          start = moment.isMoment(start) ? start : moment.utc(start, options.timeFormat);\n          end = moment.isMoment(end) ? end : moment.utc(end, options.timeFormat);\n          return {\n            start, end,\n            original: _.clone(e)\n          };\n        })\n        .sortBy(e => e.start.unix())\n        .each(e => {\n          // Calculate the duration of the event; this determines\n          // how many segments it will be in\n          var startMoment = moment.utc(e.start).startOf(scale);\n          var endMoment = moment.utc(e.end).endOf(scale).add(1, 'milliseconds');\n  \n          // For each duration, add the event to the corresponding segment\n          var segmentStart;\n          for(var i = 0, duration = endMoment.diff(startMoment, scale); i < duration; i++) {\n            segmentStart = moment.utc(startMoment).add(i, scale).unix();\n            if (!segments[segmentStart]) { segments[segmentStart] = []; }\n            segments[segmentStart].push(e.original);\n          }\n        });      \n      return segments;\n    }\n  };\n  \n  export default TimeSegments;\n  \n  \n  return TimeSegments;\n});\n"],"sourceRoot":"/source/"}