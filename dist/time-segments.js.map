{"version":3,"sources":["time-segments.js"],"names":[],"mappings":"WAAU,IAAI,EAAE,OAAO,EAAE;AACvB;AACE;;AAEA;AACA;AACA;;AAEA;;EAEH,iBAAiB,CAAC,EAAE,MAAM,EAAE;AAC3B;;AAEA;;;AAGE,aAAO,iBAAC,MAAM,EAAE,KAAK,EAAE,OAAO,EAAE;AAC9B;AACA;AACA;AACE;AACA;;AAEF;AACA;;;;;AAKA,wCAAwB,CAAC,EAAI;;;AAI3B,YAAI,WAAW,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,cAAc,CAAC,CAAC,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC;AACvE,YAAI,SAAS,GAAG,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,cAAc,CAAC,CAAC;;;AAGxF,YAAI,YAAY,CAAC;AACjB,aAAI,IAAI,CAAC,GAAG,CAAC;YAAE,QAAQ,GAAG,SAAS,CAAC,IAAI,CAAC,WAAW,EAAE,KAAK,CAAC,EAAE,CAAC,GAAG,QAAQ,EAAE,CAAC,EAAE,EAAE;AAC/E;AACA;AAA+B,oBAAQ,CAAC,YAAY,CAAC,GAAG,EAAE,CAAC;WAAE;AAC7D,kBAAQ,CAAC,YAAY,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,CAAC;SACzC;OACF,CAAC,CAAC;AACH,aAAO,QAAQ,CAAC;KACjB;GACF,CAAC;;;;;AAKF,SAAO,YAAY,CAAC;CACrB,CAAC,CAAC","file":"time-segments.js","sourcesContent":["(function(root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define(['underscore', 'moment'], factory);\n  } else if (typeof exports !== 'undefined') {\n    var _ = require('underscore');\n    var moment = require('moment');\n    module.exports = factory(_, moment);\n  } else {\n    root.TimeSegments = factory(root._, root.moment);\n  }\n})(this, function(_, moment) {\n  'use strict';\n\n  var TimeSegments = {\n  \n    // Segment an array of events by scale\n    segment(events, scale, options) {\n      scale = scale || 'weeks';\n      options = options || {};\n      _.defaults(options, {\n        startAttribute: 'start',\n        endAttribute: 'end'\n      });\n      events = _.chain(events).clone().sortBy(options.startAttribute).value();\n      var segments = {};\n  \n      // Clone our events so that we're not modifying the original\n      // objects. Loop through them, inserting the events into the\n      // corresponding segments\n      _.each(_.clone(events), e => {\n        \n        // Calculate the duration of the event; this determines\n        // how many segments it will be in\n        var startMoment = moment.utc(e[options.startAttribute]).startOf(scale);\n        var endMoment = moment.utc(e[options.endAttribute]).endOf(scale).add(1, 'milliseconds');\n  \n        // For each duration, add the event to the corresponding segment\n        var segmentStart;\n        for(var i = 0, duration = endMoment.diff(startMoment, scale); i < duration; i++) {\n          segmentStart = moment.utc(startMoment).add(i, scale).unix();\n          if (!segments[segmentStart]) { segments[segmentStart] = []; }\n          segments[segmentStart].push(_.clone(e));\n        }\n      });\n      return segments;\n    }\n  };\n  \n  export default TimeSegments;\n  \n  \n  return TimeSegments;\n});\n"],"sourceRoot":"/source/"}